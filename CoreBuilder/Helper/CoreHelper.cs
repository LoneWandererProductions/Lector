/*
 * COPYRIGHT:   See COPYING in the top level directory
 * PROJECT:     CoreBuilder.Helper
 * FILE:        CoreHelper.cs
 * PURPOSE:     Common helper methods shared by analyzers, extractors, and console tools.
 * PROGRAMMER:  Peter Geinitz (Wayfarer)
 */

using CoreBuilder.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CoreBuilder.Helper;

/// <summary>
/// Provides reusable utility methods for CoreBuilder tools.
/// </summary>
public static class CoreHelper
{
    /// <summary>
    /// Determines whether a given file should be ignored during analysis.
    /// </summary>
    /// <param name="filePath">The absolute path of the file.</param>
    /// <returns>
    /// <see langword="true"/> if the file is auto-generated or excluded; 
    /// otherwise, <see langword="false"/>.
    /// </returns>
    internal static bool ShouldIgnoreFile(string filePath)
    {
        var fileName = Path.GetFileName(filePath);

        // Skip known generated or boilerplate files
        if (fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith("AssemblyAttributes.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".xaml", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".xaml.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Contains(@"\obj\", StringComparison.OrdinalIgnoreCase) ||
            fileName.Contains(@"\bin\", StringComparison.OrdinalIgnoreCase) ||
            fileName.Equals("AssemblyInfo.cs", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        // Skip files with <auto-generated> comments in the header
        try
        {
            if (File.ReadLines(filePath).Take(10).Any(line =>
                    line.Contains("<auto-generated", StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }
        }
        catch
        {
            // If file cannot be read, skip it to avoid exceptions
            return true;
        }

        return false;
    }

    /// <summary>
    /// Determines the loop context (constant, variable, or nested) 
    /// for a given syntax node.
    /// </summary>
    /// <param name="node">The syntax node to analyze.</param>
    /// <returns>
    /// A <see cref="LoopContext"/> value indicating the loop's classification.
    /// </returns>
    internal static LoopContext GetLoopContext(SyntaxNode node)
    {
        var loops = node.Ancestors().Where(a =>
            a is ForStatementSyntax ||
            a is ForEachStatementSyntax ||
            a is WhileStatementSyntax ||
            a is DoStatementSyntax).ToList();

        if (!loops.Any())
            return LoopContext.None;

        if (loops.Count > 1)
            return LoopContext.Nested;

        var loop = loops.First();
        return loop switch
        {
            ForStatementSyntax forLoop => AnalyzeForLoop(forLoop),
            ForEachStatementSyntax => LoopContext.VariableBounded,
            WhileStatementSyntax => LoopContext.VariableBounded,
            DoStatementSyntax => LoopContext.VariableBounded,
            _ => LoopContext.VariableBounded
        };
    }

    /// <summary>
    /// Determines whether a <c>for</c> loop has a constant numeric bound.
    /// </summary>
    /// <param name="loop">The <see cref="ForStatementSyntax"/> to analyze.</param>
    /// <returns>
    /// <see cref="LoopContext.ConstantBounded"/> if the loop's upper bound is a numeric literal; 
    /// otherwise <see cref="LoopContext.VariableBounded"/>.
    /// </returns>
    private static LoopContext AnalyzeForLoop(ForStatementSyntax loop)
    {
        if (loop.Condition is BinaryExpressionSyntax { Right: LiteralExpressionSyntax literal } &&
            literal.IsKind(SyntaxKind.NumericLiteralExpression))
        {
            return LoopContext.ConstantBounded;
        }

        return LoopContext.VariableBounded;
    }

    /// <summary>
    /// Finds the root of a project by locating the nearest .csproj or directory with source files.
    /// </summary>
    /// <param name="startPath">The path to start searching from.</param>
    /// <returns>The project root directory.</returns>
    public static string FindProjectRoot(string startPath)
    {
        var dir = new DirectoryInfo(startPath);
        if (dir.Exists && dir.Extension.Equals(".csproj", StringComparison.OrdinalIgnoreCase))
            return dir.Name!;

        while (dir != null)
        {
            if (dir.GetFiles("*.csproj").Any())
                return dir.FullName;

            dir = dir.Parent;
        }

        return Path.GetDirectoryName(startPath)!;
    }

    /// <summary>
    /// Enumerates all relevant C# source files in a project directory.
    /// </summary>
    /// <param name="projectPath">The root project directory.</param>
    /// <returns>Enumerable of file paths.</returns>
    public static IEnumerable<string> GetSourceFiles(string projectPath)
    {
        return Directory.EnumerateFiles(projectPath, "*.cs", SearchOption.AllDirectories)
            .Where(f => !f.EndsWith(".xaml", StringComparison.OrdinalIgnoreCase) &&
                        !f.Contains(@"\obj\", StringComparison.OrdinalIgnoreCase) &&
                        !f.Contains(@"\bin\", StringComparison.OrdinalIgnoreCase) &&
                        !f.Contains(@"\.vs\", StringComparison.OrdinalIgnoreCase) &&
                        !f.Contains("resource", StringComparison.OrdinalIgnoreCase) &&
                        !f.Contains("const", StringComparison.OrdinalIgnoreCase));
    }
}
