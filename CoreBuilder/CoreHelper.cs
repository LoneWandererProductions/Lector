/*
 * COPYRIGHT:   See COPYING in the top level directory
 * PROJECT:     CoreBuilder
 * FILE:        CoreHelper.cs
 * PURPOSE:     Helper File that shares logic in the Project
 * PROGRAMMER:  Peter Geinitz (Wayfarer)
 */
/*
 * COPYRIGHT:   See COPYING in the top level directory
 * PROJECT:     CoreBuilder
 * FILE:        CoreHelper.cs
 * PURPOSE:     Shared static helper methods for common logic.
 * PROGRAMMER:  Peter Geinitz (Wayfarer)
 */

using CoreBuilder.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Weaver.Messages;

namespace CoreBuilder;

/// <summary>
/// Provides shared static helper methods for file handling,
/// syntax analysis, and analyzer execution.
/// </summary>
internal static class CoreHelper
{
    /// <summary>
    /// Determines whether a given file should be ignored during analysis.
    /// </summary>
    /// <param name="filePath">The absolute path of the file.</param>
    /// <returns>
    /// <see langword="true"/> if the file is auto-generated or excluded; 
    /// otherwise, <see langword="false"/>.
    /// </returns>
    internal static bool ShouldIgnoreFile(string filePath)
    {
        var fileName = Path.GetFileName(filePath);

        // Skip known generated or boilerplate files
        if (fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith("AssemblyAttributes.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Equals("AssemblyInfo.cs", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        // Skip files with <auto-generated> comments in the header
        try
        {
            if (File.ReadLines(filePath).Take(10).Any(line =>
                    line.Contains("<auto-generated", StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }
        }
        catch
        {
            // If file cannot be read, skip it to avoid exceptions
            return true;
        }

        return false;
    }

    /// <summary>
    /// Determines the loop context (constant, variable, or nested) 
    /// for a given syntax node.
    /// </summary>
    /// <param name="node">The syntax node to analyze.</param>
    /// <returns>
    /// A <see cref="LoopContext"/> value indicating the loop's classification.
    /// </returns>
    internal static LoopContext GetLoopContext(SyntaxNode node)
    {
        var loops = node.Ancestors().Where(a =>
            a is ForStatementSyntax ||
            a is ForEachStatementSyntax ||
            a is WhileStatementSyntax ||
            a is DoStatementSyntax).ToList();

        if (!loops.Any())
            return LoopContext.None;

        if (loops.Count > 1)
            return LoopContext.Nested;

        var loop = loops.First();
        return loop switch
        {
            ForStatementSyntax forLoop => AnalyzeForLoop(forLoop),
            ForEachStatementSyntax => LoopContext.VariableBounded,
            WhileStatementSyntax => LoopContext.VariableBounded,
            DoStatementSyntax => LoopContext.VariableBounded,
            _ => LoopContext.VariableBounded
        };
    }

    /// <summary>
    /// Executes an analyzer function on the specified file and 
    /// returns the formatted <see cref="CommandResult"/>.
    /// </summary>
    /// <param name="args">Command arguments (expects a file path as the first argument).</param>
    /// <param name="analyzerFunc">
    /// The analyzer delegate accepting file path and content, returning diagnostics.
    /// </param>
    /// <param name="analyzerName">The display name of the analyzer.</param>
    /// <returns>
    /// A <see cref="CommandResult"/> indicating success or failure and containing diagnostic output.
    /// </returns>
    internal static CommandResult Run(
        string[] args,
        Func<string, string, IEnumerable<Diagnostic>> analyzerFunc,
        string analyzerName)
    {
        if (args.Length < 1)
            return CommandResult.Fail($"Missing argument: file path for {analyzerName}.");

        var filePath = args[0];
        if (!File.Exists(filePath))
            return CommandResult.Fail($"File not found: {filePath}");

        try
        {
            var fileContent = File.ReadAllText(filePath);
            var diagnostics = analyzerFunc(filePath, fileContent).ToList();

            if (diagnostics.Count == 0)
                return CommandResult.Ok($"No issues found by {analyzerName}.");

            var sb = new StringBuilder();
            sb.AppendLine($"{analyzerName} results for: {filePath}");
            sb.AppendLine(new string('-', 80));
            diagnostics.ForEach(d => sb.AppendLine(d.ToString()));
            sb.AppendLine(new string('-', 80));
            sb.AppendLine($"{diagnostics.Count} issues found.");

            return CommandResult.Ok(sb.ToString(), diagnostics, EnumTypes.Wstring);
        }
        catch (Exception ex)
        {
            return CommandResult.Fail($"{analyzerName} execution failed: {ex.Message}", ex, EnumTypes.Wstring);
        }
    }

    /// <summary>
    /// Determines whether a <c>for</c> loop has a constant numeric bound.
    /// </summary>
    /// <param name="loop">The <see cref="ForStatementSyntax"/> to analyze.</param>
    /// <returns>
    /// <see cref="LoopContext.ConstantBounded"/> if the loop's upper bound is a numeric literal; 
    /// otherwise <see cref="LoopContext.VariableBounded"/>.
    /// </returns>
    private static LoopContext AnalyzeForLoop(ForStatementSyntax loop)
    {
        if (loop.Condition is BinaryExpressionSyntax { Right: LiteralExpressionSyntax literal } &&
            literal.IsKind(SyntaxKind.NumericLiteralExpression))
        {
            return LoopContext.ConstantBounded;
        }

        return LoopContext.VariableBounded;
    }
}
