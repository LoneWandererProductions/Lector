/*
 * COPYRIGHT:   See COPYING in the top level directory
 * PROJECT:     CoreBuilder
 * FILE:        CoreHelper.cs
 * PURPOSE:     Helper File that shares logic in the Project
 * PROGRAMMER:  Peter Geinitz (Wayfarer)
 */

using System;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CoreBuilder;

/// <summary>
///     Static Helper class
/// </summary>
internal static class CoreHelper
{
    /// <summary>
    ///     Files that should be ignored.
    /// </summary>
    /// <param name="filePath">The file path.</param>
    /// <returns>Checks if file should be ignored.</returns>
    internal static bool ShouldIgnoreFile(string filePath)
    {
        var fileName = Path.GetFileName(filePath);

        // Check filename-based exclusions
        if (fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith("AssemblyAttributes.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Equals("AssemblyInfo.cs", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        // Check for <auto-generated> comment in the first few lines
        try
        {
            if (File.ReadLines(filePath).Take(10).Any(line =>
                    line.Contains("<auto-generated", StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }
        }
        catch
        {
            return true; // If unreadable, best to skip
        }

        return false;
    }

    /// <summary>
    /// Detects the loop context of a node (constant, variable, nested).
    /// </summary>
    /// <param name="node">The node.</param>
    /// <returns>LoopContext enum.</returns>
    internal static LoopContext GetLoopContext(SyntaxNode node)
    {
        var loops = node.Ancestors().Where(a =>
            a is ForStatementSyntax ||
            a is ForEachStatementSyntax ||
            a is WhileStatementSyntax ||
            a is DoStatementSyntax).ToList();

        if (!loops.Any()) return LoopContext.None;
        if (loops.Count > 1) return LoopContext.Nested;

        var loop = loops.First();
        return loop switch
        {
            ForStatementSyntax forLoop => AnalyzeForLoop(forLoop),
            ForEachStatementSyntax => LoopContext.VariableBounded,
            WhileStatementSyntax => LoopContext.VariableBounded,
            DoStatementSyntax => LoopContext.VariableBounded,
            _ => LoopContext.VariableBounded
        };
    }

    /// <summary>
    /// Checks if a for loop has a constant numeric bound.
    /// </summary>
    /// <param name="loop">The for loop.</param>
    /// <returns>LoopContext.ConstantBounded or VariableBounded.</returns>
    private static LoopContext AnalyzeForLoop(ForStatementSyntax loop)
    {
        if (loop.Condition is BinaryExpressionSyntax { Right: LiteralExpressionSyntax literal } && literal.IsKind(SyntaxKind.NumericLiteralExpression))
        {
            return LoopContext.ConstantBounded;
        }

        return LoopContext.VariableBounded;
    }
}
